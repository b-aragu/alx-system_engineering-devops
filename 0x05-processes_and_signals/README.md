---
banner: "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcToilF_nC711LcEsUtRNtghu1wd6dmkU-CnFg&usqp=CAU"
---

### Process and process ID

-   **`PID`** - it is and identification number assigned to a process when it is created.
-   **`process`** - It is an executing instance of a program assigned a unique PID which is a non negative integer. Beside its own ID, a parent process ID is also associated with it.

1.  Foreground processes - Depends on user for input (interactive process)
2.  Background process - Run independently of the user. (non-interactive or automatic processes)

-   `init` is the only process guaranteed to always have the same PID on any session on any system because `init` is always the first process on the system and is the ancestor of other processes. That PID is *1*
-   Large PID doesn't necessarily mean that there are that many processes. It is due do the fact that PIDS arent used in order to prevent possible errors.
-   Default maximum PID value is *32, 767* and is essentially the maximum number of processes that can exist simultaneously on a system.
-   Maximum number of processes on a system is limited by the amount of physical memories available.
-   **`ps command`** - show PIDS of processes currently on the system of the **`pstree`**
-   Information on current processes is stored in the `/proc` filesystem.

#### Main() function

-   A C program start with a call to the main function
-   Prototype to main is `int main(int argc, char *argv[]);`
-   return type of main is int and signify if the program executed successfully or not. if it return `0` it executed sccessfully otherwise indicates a failure.

``` c
#include <stdio.h>
int main(int argc, char *argv)
{
    int count = argc;
    printf("The number of argument passed is %d \n", count);
    int c = 0;
    while (c < count)
    {
        printf("The argument [%d] is %s", c + 1, argv[c] );
        c ++;
    }
    return 0;
}
```

#### Environment list

-   **`env`** - displays a list=value pair that represents your shell environment.
-   A process also has its own environment and there are 2 ways to access a process environment:
    1.  Through the global variable **`extern char **extern`**
    2.  Through the third argument to the main function **`chat *envp[]`**
-   Accessing the environment from within a process

``` c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

/**
* Acess the environment from within a process
*/

extern char **environ;

int main(int argc, char *argv[])
{
  int count = 0;

  printf("\n");

  while (environ[count]  != NULL)
  {
    printf("[%s] :: ", environ[count]);
    count ++;
  }

  char *val = getenv("USER");
  printf("\n\n CURRENT VALUE OF ENVIRONMENT VARIABLE USER is [%s]\n", val);

  if (setenv("USER", "baragu", 1))
  {
    printf("Failed to set environment variable\n");
    return 1;
  }
  printf("\n successfuly added a new value to existing env var USER");
  
  while(1)
  {
    sleep(1);
  }

  return 0;
}
```

**`getenv`** - get value of a particular environment variable
**`setenv`** - set a new value to an environment variable

#### Linux Signals

-   A signal is an event generated by the UNIX and LINUX system in response to some conditions. Upon a receipt of a signal,a process may take action.
-   A signal is just like an interrupt; when it is generated at the user level, a call is made to the kernel of the OS, which then acts accordingly.
    \##### Common signals
    **`SIGHUP`** - Hangup detected on controlling terminal or death of controlling process.
    **`SIGINT`** - issued when user send an interrupt signal *( Ctrl + C)*
    **`SIGQUIT`** - Issued if user sends a quit signal *(Ctrl + D)*
    **`SIGFPE`** - issued when an illegal mathematical operation is attempted
    **`SIGKILL`** - If a process get this signal it must quit immediately and it does not perform any cleanup operation.
    **`SIGTERM`** - Software termination signal (sent kill by default)
    **`SIGALRM`** - alarm clock signal (used for timers)
